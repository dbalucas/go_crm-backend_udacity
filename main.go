package main

import (
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"strconv"

	_ "github.com/dbalucas/Go-CRM-Backend_Udacity/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/dbalucas/Go-CRM-Backend_Udacity/models"
	"github.com/dbalucas/Go-CRM-Backend_Udacity/util"
	_ "github.com/lib/pq" // github.com/go-sql-driver/mysql but for postgres

	"github.com/google/uuid"
	"github.com/gorilla/mux"
	httpSwagger "github.com/swaggo/http-swagger/v2"
)

// Repository slice of all Customers
type CustomerRepository struct {
	customers []models.Customer
}

// Intiate the Database globally
var customerRepository = &CustomerRepository{}

// retrieve all customers from database
func (c *CustomerRepository) FindAll() ([]models.Customer, error) {
	return c.customers, nil
}

// retrieve the database index by uuid
func (c *CustomerRepository) findIndexByID(id uuid.UUID) (int, error) {
	for index, customer := range c.customers {
		if customer.ID == id {
			return index, nil
		}
	}
	return 0, errors.New("not found")
}

// find a user by uuid in database if exists
func (c *CustomerRepository) FindByID(id uuid.UUID) (models.Customer, error) {
	index, err := c.findIndexByID(id)
	if err != nil {
		return models.Customer{}, errors.New("not found")
	}
	return c.customers[index], nil
}

// Save newCustomer to Database (UUID generated automatically)
func (c *CustomerRepository) Save(newCustomer models.Customer) (models.Customer, error) {
	// create new ID if not exists
	if newCustomer.ID == uuid.Nil {
		newCustomer.ID = getNewUniqueID()
	}
	c.customers = append(c.customers, newCustomer)

	return newCustomer, nil
}

// update customer in Database (UUID generated automatically)
func (c *CustomerRepository) Update(updateCustomer models.Customer, customerID uuid.UUID) (models.Customer, error) {
	// Find customer uuid in dbConfig or return error
	index, err := customerRepository.findIndexByID(customerID)
	if err != nil {
		err = errors.New("provided uuid " + customerID.String() + " not found")
		return models.Customer{}, err
	}

	updateCustomer.ID = customerID

	// update database at index
	c.customers[index] = updateCustomer

	return c.customers[index], nil
}

// delete a customer by uuid from database
func (c *CustomerRepository) DeleteByID(id uuid.UUID) error {
	index, err := c.findIndexByID(id)
	if err != nil {
		return errors.New("can not delete by ID: " + id.String() + " not found")
	}
	c.customers = deleteAtIndex(c.customers, index)
	return nil
}

// from inserted slice, remove item by slice index
func deleteAtIndex(slice []models.Customer, index int) []models.Customer {
	return append(slice[:index], slice[index+1:]...)
}

func initDB() {

	customerRepository.Save(models.Customer{Name: "Anton", Role: "account manager", Email: "sales.Anton@gmail.com", Phone: 4987654321, Contacted: true})
	customerRepository.Save(models.Customer{Name: "Bernd", Role: "marketing", Email: "marketing.bernd@gmail.com", Phone: 4987654321, Contacted: true})
	customerRepository.Save(models.Customer{Name: "CÃ¤sar", Role: "product manager", Email: "product.caesar@web.com", Phone: 4987654321, Contacted: true})
	customerRepository.Save(models.Customer{Name: "Doris", Role: "admin", Email: "admin.doris@gmail.com", Phone: 4987654321, Contacted: true})
	customerRepository.Save(models.Customer{Name: "Emil", Role: "Evangelist", Email: "Evangelist.Emil@gmail.com", Phone: 4987654321, Contacted: true})

	fmt.Printf("database initialized with %v entities. \n", len(customerRepository.customers))
}

func getNewUniqueID() uuid.UUID {
	return uuid.New()
}

// brief overview of the API
func serverStatic(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "text/html")
	http.ServeFile(w, r, "static/index.html")
}

// getCustomers godoc
//
//	@Summery	Recieve all customers
//	@Description
//	@Tags		customers
//	@Produce	json
//	@Success	200	{slice}	Customers
//	@Router		/customers [get]
func getCustomers(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(customerRepository.customers)
	// add pagination
}

// addCustomer godoc
//
//	@Summary		Add a new customer
//	@Description	From POST request create new Customer if not exists
//	@Tags			customer
//	@Accept			json
//	@Produce		json
//	@Param			customer	body		Customer	true	"Add new Customer"
//	@Success		200			{object}	Customer
//	@Router			/customers [post]
func addCustomer(w http.ResponseWriter, r *http.Request) {
	// read the request body & parse JSON body
	decoder := json.NewDecoder(r.Body)

	var addedCustomers []models.Customer

	// insert new Entry into customerRepository
	for {
		// new customer entry
		var newCustomer models.Customer

		err := decoder.Decode(&newCustomer)
		if err == io.EOF {
			// done
			break
		}
		if err != nil {
			http.Error(w, err.Error(), http.StatusBadRequest)
			break
		}

		addedCustomer, err := customerRepository.Save(newCustomer)
		if err != nil {
			http.Error(w, "save new entry failed: "+addedCustomer.Name, http.StatusBadRequest)
		}

		// get new entry from database for validation pupose
		addedCustomer, err = customerRepository.FindByID(addedCustomer.ID)
		if err != nil {
			http.Error(w, "could retrieve newly added item from database "+addedCustomer.ID.String(), http.StatusNotFound)
			return // early fail to avoid duplicate writing of status code
		}

		addedCustomers = append(addedCustomers, addedCustomer)
	}

	// output new entry
	w.WriteHeader(http.StatusCreated)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(addedCustomers)
}

// getCustomer godoc
//
//	@Summery		Recieve single customer by uuid
//	@Description	Retrieve single customer by ID in /customer/{id}
//	@Tags			customers
//	@Accept			json
//	@Produce		json
//	@Success		200	customer	Customer
//	@Router			/customers/{id} [get]
func getCustomer(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	CustomerID, _ := uuid.Parse(vars["id"])

	foundCustomer, err := customerRepository.FindByID(CustomerID)
	if err != nil {
		http.Error(w, "Customer not found", http.StatusNotFound)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(foundCustomer)
}

// updateCustomer godoc
//
//	@Summary		Update an existing customer by its uuid
//	@Description	From POST request update an existing customer by its uuid if exists
//	@Tags			customer
//	@Accept			json
//	@Produce		json
//	@Param			customer	body		Customer	true	"update new Customer"
//	@Success		200			{object}	Customer
//	@Router			/customers [put]
func updateCustomer(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	CustomerID, _ := uuid.Parse(vars["id"])
	var updateCustomer models.Customer

	// read the request body
	request, _ := io.ReadAll(r.Body)
	//	parse JSON body
	err := json.Unmarshal(request, &updateCustomer)
	if err != nil {
		w.WriteHeader(http.StatusBadRequest)
		return // early fail to avoid duplicate writing of status code
	}
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return // early  fail to avoid duplicate writing of status code
	}

	customerRepository.Update(updateCustomer, CustomerID)
	if err != nil {
		http.Error(w, "could not update customer "+updateCustomer.ID.String(), http.StatusNotFound)
		return // fail to avoid duplicate writing of status code
	}
	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(updateCustomer)
}

// deleteCustomer godoc
//
//	@Summary		Update an existing customer by its uuid
//	@Description	remove a single Customer by ID
//	@Tags			customer
//	@Accept			json
//	@Produce		json
//	@Param			customer	body	Customer	true	"delete new Customer"
//	@Success		200
//	@Router			/customers [delete]
func deleteCustomer(w http.ResponseWriter, r *http.Request) {
	// Get ID from Var ULR
	vars := mux.Vars(r)
	customerID, _ := uuid.Parse(vars["id"])

	err := customerRepository.DeleteByID(customerID)
	// if not found fail else remove
	if err != nil {
		w.WriteHeader(http.StatusNotFound)
	} else {
		w.WriteHeader(http.StatusOK)
		fmt.Fprintf(w, "Customer %v was removed", customerID)
	}
}

//	@title			CRM - GOlang API Documentation
//	@version		1.0
//	@description	This is a sample crm-server and contains a final project of a udacity course
//	@termsOfService	http://swagger.io/terms/

//	@contact.name	https://github.com/dbalucas
//	@contact.backendUrl	https://github.com/dbalucas
//	@contact.email	https://github.com/dbalucas

// license.name MIT License
//	@license.backendUrl	https://github.com/dbalucas/go_crm-backend_udacity/blob/main/LICENSE

// @host		localhost:3000
// @BasePath	/
func main() {
	const port = 3000
	const host = "0.0.0.0"

	var backendUrl = host + ":" + strconv.Itoa(port)

	// // Database configuration
	// dbConfig := DbConfig{
	// 	dbHost:     "localhost",
	// 	dbUser:     "postgres",
	// 	dbPassword: "postgres",
	// 	dbName:     "postgres",
	// 	dbPort:     "5432",
	// 	dbSslMode:  "disable",
	// }
	// dsn, _ := dbConfig.getDsn()

	dsn, err := util.ReadConfigYAML()
	if err != nil {
		log.Panic("no postgres connection string")
	}

	models.ConnectDB(dsn)

	initDB()

	// Webserver Routing
	router := mux.NewRouter()

	router.HandleFunc("/", serverStatic).Methods("GET")

	router.HandleFunc("/customers", getCustomers).Methods("GET")
	router.HandleFunc("/customers", addCustomer).Methods("POST")
	router.HandleFunc("/customers/_batch/create", addCustomer).Methods("POST")
	router.HandleFunc("/customers/{id}", getCustomer).Methods("GET")
	router.HandleFunc("/customers/{id}", updateCustomer).Methods("PUT")
	router.HandleFunc("/customers/{id}", deleteCustomer).Methods("DELETE")

	router.PathPrefix("/swagger").Handler(httpSwagger.WrapHandler).Methods(http.MethodGet)

	// startup webserver
	log.Panic(http.ListenAndServe(backendUrl, router))
	fmt.Println("Starting the server on: ", backendUrl)

}
